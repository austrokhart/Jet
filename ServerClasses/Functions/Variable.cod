class "Класс для работы с переменными";
import classes Functions.Variable, Functions.Array, Functions.Class, Functions.Object;

inclass


  type var_type = (
    TYPE_STRING  = 1,
    TYPE_INTEGER = 2,
    TYPE_REAL    = 3,
    TYPE_BOOLEAN = 4,
    TYPE_DATE    = 5,
    TYPE_OBJECT  = 6,
    TYPE_VARIANT = 7,
    TYPE_ARRAY   = 8,
    TYPE_CLASS   = 9,
    TYPE_NIL     = 10
  );


  func var_to_int(const value: variant): integer;
    
    return Kernel.Mathematic.int(Kernel.Mathematic.trunc(value));
  end;

  func var_to_real(const value: variant): real;
    
    return Kernel.Mathematic.num(value);
  end;


  func var_to_dump(const value: variant): string;


    var escaper: StringEscaper;


    func to_str(value: variant): string;


      func from_nil(value: variant): string;
      
        return "(nil) nil";
      end;

      func from_boolean(value: boolean): string;
      
        return "(boolean) " +if (value, "true", "false");
      end;

      func from_integer(value: integer): string;
      
        return "(integer) " +str(value);
      end;

      func from_real(value: real): string;
      
        return "(real) " +str(value);
      end;

      func from_string(value: string): string;
      
        return '(string) "' +escaper.escape(value) +'"';
      end;

      func from_date(value: string): string;
      
        return '(date) ' +str(value);
      end;

      func from_array(value: variant[]): string;

        var values: variant[];

        values = value;

        with array_map(values) do
          while __next do __apply(to_str(__item)); end; __assign(values);
        end;

        return '(array) [' +array_implode(values, ', ') +']';
      end;

      func from_class(value: class): string;

        return '(class) ' +class_name(value);
      end;

      func from_object(value: Object): string;
        
        var properties: string[];

        properties = object_props(value);

        with array_filter(properties) do
          while __next do __apply(object_has_own_member(value, __item)); end; __assign(properties);
        end;

        with array_map(properties) do
          while __next do __apply(__item +': ' +to_str(object_get_prop(value, __item))); end; __assign(properties);
        end;

        return '(object) ' +class_name(class_from(value)) +' {' +array_implode(properties, ', ') +'}';
      end;

      func from_unknown(value: variant): string;
        
        return '(unknown) ' +str(value);
      end;


      if var_is_nil(value) then
        return from_nil(value);

      elsif var_is_boolean(value) then
        return from_boolean(value);

      elsif var_is_integer(value) then
        return from_integer(value);

      elsif var_is_real(value) then
        return from_real(value);

      elsif var_is_string(value) then
        return from_string(value);

      elsif var_is_date(value) then
        return from_date(value);

      elsif var_is_array(value) then
        return from_array(value);

      elsif var_is_class(value) then
        return from_class(value);

      elsif var_is_object(value) then
        return from_object(value);

      else
        return from_unknown(value);
      end;
    end;


    escaper = StringEscaper.new;

    return to_str(value);
  end;


  func var_is_string(const value: variant): boolean;

    return Kernel.System.varType(value) = TYPE_STRING;
  end;

  func var_is_integer(const value: variant): boolean;
    
    return Kernel.System.varType(value) = TYPE_INTEGER;
  end;

  func var_is_real(value: variant): boolean;
    
    return Kernel.System.varType(value) = TYPE_REAL;
  end;

  func var_is_number(value: variant): boolean;
    
    return var_is_integer(value) or var_is_real(value);
  end;

  func var_is_boolean(value: variant): boolean;
    
    return Kernel.System.varType(value) = TYPE_BOOLEAN;
  end;

  func var_is_date(value: variant): boolean;
    
    return Kernel.System.varType(value) = TYPE_DATE;
  end;

  func var_is_object(value: variant): boolean;
    
    return Kernel.System.varType(value) = TYPE_OBJECT;
  end;

  func var_is_variant(value: variant): boolean;
    
    return Kernel.System.varType(value) = TYPE_VARIANT;
  end;

  func var_is_array(value: variant): boolean;

    return Kernel.System.varType(value) = TYPE_ARRAY;
  end;

  func var_is_class(value: variant): boolean;

    return Kernel.System.varType(value) = TYPE_CLASS;
  end;

  func var_is_nil(value: variant): boolean;
    
    return Kernel.System.varType(value) = TYPE_NIL;
  end;


  -- проверяет равенство значений
  func var_equal(const value, other_value: variant): boolean;

    return value in [other_value];
  end;

  -- проверяет неравенство значений
  func var_not_equal(const value, other_value: variant): boolean;
    
    return not var_equal(value, other_value);
  end;


  -- проверяет идентичность значений, возвращает истину если значения и типы переменных совпадают
  func var_identical(value, other_value: variant): boolean;
    
    return Kernel.System.varType(value) = Kernel.System.varType(other_value) and var_equal(value, other_value);
  end;

  -- проверяет неидентичность
  func var_not_identical(value, other_value: variant): boolean;
    
    return not var_identical(value, other_value);
  end;


  -- проверяет принадлежность значения к типу, в качестве аргумента expected необходимо передать соответствующую константу класса
  func var_type_is(value: variant; expected: var_type): boolean;

    return Kernel.System.varType(value) = expected;
  end;

  func var_class_is(value: variant; expected: class): boolean;
    
    return (var_is_class(value) or var_is_object(value)) and value.inheritsFrom(expected);
  end;

  -- проверяет для значения принадлежность к типу объект и к классу expected
  func var_instance_of(value: variant; expected: class): boolean;
    
    result = (var_is_object(value) and value.inheritsFrom(expected));
  end;



  -- обменивает значения переменных
  proc var_swap(var variable: variant; var other_variable: variant);
    
    var temp: variant;
        temp = variable;

    variable = other_variable;
    other_variable = temp;
  end;
end