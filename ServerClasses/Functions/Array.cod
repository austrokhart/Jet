class "Класс для работы с массивами";
import classes Functions.Indexing, Functions.Math, Functions.Variable;

inclass


  type array_pad_direction = (
    ARRAY_PAD_LEFT,
    ARRAY_PAD_RIGHT,
    ARRAY_PAD_BOTH
  );


  type array_trim_direction = (
    ARRAY_TRIM_LEFT,
    ARRAY_TRIM_RIGHT,
    ARRAY_TRIM_BOTH
  );


  type array_pos_result = (
    ARRAY_POS_OFFSET,
    ARRAY_POS_LENGTH
  );


  type array_method_each   = Methods.Functions.Array.Each;
  type array_method_filter = Methods.Functions.Array.Filter;
  type array_method_map    = Methods.Functions.Array.Map;
  type array_method_reduce = Methods.Functions.Array.Reduce;


  func array_from(const value: variant): variant[];

    return self.md_array_from(value);
  end;


  func array_length(const array: variant[]): integer;
    
    return self.md_array_length(array);
  end;


  func array_has_content(const array: variant[]): boolean;

    return self.md_array_has_content(array);
  end;


  func array_get(const array: variant[]; index: integer; default_value: variant = nil): variant;

    return self.md_array_get(array, index, nil, default_value);
  end;


  proc array_set(var array: variant[]; index: integer; value: variant);

    self.md_array_set(array, index, nil, value);
  end;


  proc array_unset(var array: variant[]; index: integer);

    self.md_array_unset(array, index, nil);
  end;


  func array_is_set(const array: variant[]; index: integer): boolean;

    return self.md_array_is_set(array, index, nil);
  end;


  proc array_clear(var array: variant[]; path: integer[] = nil);

    self.md_array_clear(array, nil);
  end;


  proc array_append(var array: variant[]; value: variant);

    self.md_array_append(array, value);
  end;


  proc array_prepend(var array: variant[]; value: variant);

    self.md_array_prepend(array, value);
  end;


  proc array_extend(var array: variant[]; value: variant[]);
    
    self.md_array_extend(array, value);
  end;


  func array_pos(const array: variant[]; value: variant[]; offset: integer = 1): integer;

    return self.md_array_pos(array, nil, value, offset);
  end;


  func array_pos_any(const array: variant[]; values: variant[]; offset: integer = 1): integer[];

    return self.md_array_pos_any(array, nil, values, offset);
  end;


  func array_contains(const array: variant[]; value: variant[]; offset: integer = 1): boolean;
    
    return self.md_array_contains(array, nil, value, offset);
  end;


  func array_contains_any(const array: variant[]; values: variant[]; offset: integer = 1): boolean;
    
    return self.md_array_contains_any(array, nil, values, offset);
  end;


  func array_starts_with(const array: variant[]; value: variant[]): boolean;
    
    return self.md_array_starts_with(array, nil, value);
  end;


  func array_starts_with_any(const array: variant[]; values: variant[]): boolean;
    
    return self.md_array_starts_with_any(array, nil, values);
  end;


  func array_ends_with(const array: variant[]; value: variant[]): boolean;
    
    return self.md_array_ends_with(array, nil, value);
  end;


  func array_ends_with_any(const array: variant[]; values: variant[]): boolean;
    
    return self.md_array_ends_with_any(array, nil, values);
  end;


  func array_slice(const array: variant[]; offset: integer = 1; length: variant = nil): variant[];

    return self.md_array_slice(array, nil, offset, length);
  end;


  func array_splice(var array: variant[]; value: variant[]; offset: integer = 1; length: variant = nil): variant[];

    return self.md_array_splice(array, value, offset, length);
  end;


  func array_concat(const arrays: variant[]): variant[];

    return self.md_array_concat(arrays);
  end;


  func array_repeat(const value: variant[]; count: integer): variant[];
    
    return self.md_array_repeat(value, count);
  end;


  proc array_swap(var array: variant[]; index, other_index: integer);
    
    self.md_array_swap(array, index, other_index);
  end;


  proc array_reverse(var array: variant[]);

    self.md_array_reverse(array);
  end;


  proc array_pad(var array: variant[]; direction: array_pad_direction; value: variant[]; length: integer);

    self.md_array_pad(array, direction, value, length);
  end;


  proc array_sort(var array: variant[]);

    self.md_array_sort(array, nil);
  end;


  func array_each(const array: variant[]): array_method_each;
    
    return self.md_array_each(array, nil);
  end;


  func array_filter(const array: variant[]): array_method_filter;
    
    return self.md_array_filter(array, nil);
  end;


  func array_map(const array: variant[]; path: integer[] = nil): array_method_map;
    
    return self.md_array_map(array, nil);
  end;


  func array_reduce(const array: variant[]; initial_value: variant): array_method_reduce;
    
    return self.md_array_reduce(array, nil, initial_value);
  end;


  func array_implode(const array: variant[]; separator: string = " "): string;

    return self.md_array_implode(array, separator);
  end;


  func md_array_from(const value: variant): variant[];

    if var_is_array(value) then
      result = value;

--    elsif var_instance_of(value, ArrayObject) then
--      result = value.array_from;

    elsif var_is_nil(value) then
      result = [];

    else
      result = [value];
    end;
  end;


  func md_array_length(const array: variant[]): integer;
    
    return Kernel.System.lengthOfArray(array);
  end;


  func md_array_has_content(const array: variant[]): boolean;

    -- сравнение с [] невозможно, возникают ошибки
    return self.md_array_length(array) <> 0;
  end;


  func md_array_get(const array: variant[]; index: integer; path: integer[] = nil; default_value: variant = nil): variant;

    -- функция должна возвращать значение элемента с индексом index и последующими индексами path в массиве array, если элемент установлен, иначе значение по-умолчанию
    --
    -- используем алгоритм:
    -- для начала проверим, что элемент с индексом index установлен (это быстро, потому что проверка проходит на единственной плоскости)
    -- если установлен, то: если измерение path не задано, вернём значение элемента, иначе вызовем функцию рекурсивно с сокращением path;
    -- иначе вернём значение по-умолчанию

    index = handle_offset(index, self.md_array_length(array));

    if self.md_array_is_set(array, index) then
      if not self.md_array_has_content(path) then
        return array[index];

      elsif var_is_array(array[index]) then
        return self.md_array_get(array[index], path[1], self.md_array_slice(path, nil, 2), default_value);
      end;
    end;

    return default_value;
  end;


  proc md_array_set(var array: variant[]; index: integer; path: integer[] = nil; value: variant);

    -- функция должна устанавливать элемент с индексом index, последующими индексами path и значением value в массиве array
    --
    -- используем алгоритм:
    --
    -- если измерение path не задано, установим значение (это быстро, потому что перед нами единственная плоскость, где всегда можно установить элемент)
    -- иначе если элемент установлен и является массивом, вызовем функцию рекурсивно с сокращением path
    --
    -- передача неустановленного значения по ссылке задаёт его со значением nil!
    -- поэтому до рекурсивного вызова используется проверка на установленность элемента

    index = handle_offset(index, self.md_array_length(array));

    if not self.md_array_has_content(path) then
      array[index] = value;

    elsif self.md_array_is_set(array, index) and var_is_array(array[index]) then
      self.md_array_set(array[index], path[1], self.md_array_slice(path, nil, 2), value);
    end;
  end;


  proc md_array_unset(var array: variant[]; index: integer; path: integer[] = nil);

    -- алгоритм аналогчен использующемуся в процедуре self.md_array_set

    index = handle_offset(index, self.md_array_length(array));

    if not self.md_array_has_content(path) then
      Kernel.System.deleteFromArray(array, index);

    elsif self.md_array_is_set(array, index) and var_is_array(array[index]) then
      self.md_array_unset(array[index], path[1], self.md_array_slice(path, nil, 2));
    end;
  end;


  func md_array_is_set(const array: variant[]; index: integer; path: integer[] = nil): boolean;

    -- функция возвращает истину, если в массиве array установлен элемент с индексом index и последующими индексами path

    -- используем алгоритм:
    -- индекс установлен, если он больше нуля и вызов функции nextArrItem для предыущего индекса возвращает исходный индекс
    -- если индекс установлен, то: если измерение path задано, вызовем функцию рекурсивно с сокращением path, иначе вернём истину;
    -- иначе вернём ложь

    if index > 0 and Kernel.System.nextArrItem(array, index -1) = index then

      if not self.md_array_has_content(path) then
        return true;

      elsif var_is_array(array[index]) then
        return self.md_array_is_set(array[index], path[1], self.md_array_slice(path, nil, 2));
      end;
    end;

    return false;
  end;


  proc md_array_clear(var array: variant[]; path: integer[] = nil);

    -- во время разустановки происходит смещение индексов, что не даёт обработать элементы по порядку
    -- поэтому обработаем в обратном порядке

    with Iterator.new(1, self.md_array_length(array)) do
      __end;
      while __previous do self.md_array_unset(array, __index, path); end;
    end;
  end;


  proc md_array_append(var array: variant[]; value: variant);

    Kernel.System.insertInArray(array, self.md_array_length(array) +1, value);
  end;


  proc md_array_prepend(var array: variant[]; value: variant);

    Kernel.System.insertInArray(array, 1, value);
  end;


  proc md_array_extend(var array: variant[]; value: variant[]);
    
    with Iterator.new(1, self.md_array_length(value)) do
      while __next do self.md_array_append(array, value[__index]); end;
    end;
  end;


  func md_array_pos(const array: variant[]; path: integer[]; value: variant[]; offset: integer = 1): integer;

    -- функция возвращает индекс и длину вхождения последовательности value в массив array в плоскости path с началом в offset
    --
    -- используем алгоритм:
    --
    -- переберём массив array, начиная со смещения offset, и для каждого элемента:
    --   если совпадение ещё не найдено и текущий элемент совпадает с первым элементом последовательности value, запишем смещение и длину совпадения
    --   иначе если совпадение уже найдено и текущий элемент совпадает с соответствующим элементом последовательности value, нарастим длину совпадения
    --   иначе если совпадение уже найдено и текущий элемент не совпадает с соответствующим элементом последовательности value, вернёмся к началу сопадения и очистим данные о нём;
    --   после всего, если длина совпадения соответствует длине последовательности value, вернём смещение совпадения
    --
    -- если совпадение не было найдено, вернём -1

    var not_found, match: integer[];

    offset = handle_offset(offset, self.md_array_length(array));

    not_found = [-1, 0];
    match = not_found;

    with Iterator.new(offset, self.md_array_length(array)) do
      while __next do

        if match = not_found and self.md_array_get(array, __index, path) = value[match[self.ARRAY_POS_LENGTH] +1] then -- здесь нужно было использовать var_equal, но значения сравниваются и так
          match[self.ARRAY_POS_OFFSET] = __index;
          match[self.ARRAY_POS_LENGTH] = match[self.ARRAY_POS_LENGTH] +1;

        elsif match <> not_found and self.md_array_get(array, __index, path) = value[match[self.ARRAY_POS_LENGTH] +1] then
          match[self.ARRAY_POS_LENGTH] = match[self.ARRAY_POS_LENGTH] +1;

        elsif match <> not_found then
          __index = match[self.ARRAY_POS_OFFSET];
          match = not_found;
        end;

        if match[self.ARRAY_POS_LENGTH] = self.md_array_length(value) then return match[self.ARRAY_POS_OFFSET]; end;
      end;
    end;

    return not_found[self.ARRAY_POS_OFFSET];
  end;


  func md_array_pos_any(const array: variant[]; path: integer[]; values: variant[]; offset: integer = 1): integer[];

    var not_found, match: integer[];

    not_found = [-1, 0];
    result = not_found;

    with Iterator.new(1, self.md_array_length(values)) do
      while __next do

        match[self.ARRAY_POS_OFFSET] = md_array_pos(array, path, values[__index], offset);
        match[self.ARRAY_POS_LENGTH] = if (match[self.ARRAY_POS_OFFSET] <> not_found[self.ARRAY_POS_OFFSET], self.md_array_length(values[__index]), not_found[self.ARRAY_POS_LENGTH]);

        if match <> not_found and (result = not_found or match[self.ARRAY_POS_OFFSET] < result[self.ARRAY_POS_OFFSET]) then
          result = match;
        end;
      end;
    end;

    return result;
  end;


  func md_array_contains(const array: variant[]; path: integer[] = nil; value: variant[]; offset: integer = 1): boolean;
    
    return self.md_array_pos(array, path, value, offset) <> -1;
  end;


  func md_array_contains_any(const array: variant[]; path: integer[] = nil; values: variant[]; offset: integer = 1): boolean;
    
    return self.md_array_pos_any(array, path, values, offset) <> [-1, 0];
  end;


  func md_array_starts_with(const array: variant[]; path: integer[] = nil; value: variant[]): boolean;
    
    with Iterator.new(1, self.md_array_length(value)) do
      while __next do
        if self.md_array_get(array, __index, path) <> self.md_array_get(value, __index, path) then return false; end;
      end;
    end;

    return true;
  end;


  func md_array_starts_with_any(const array: variant; path: integer[] = nil; values: variant[]): boolean;
    
    with Iterator.new(1, self.md_array_length(values)) do
      while __next do
        if self.md_array_starts_with(array, path, values[__index]) then return true; end;
      end;
    end;

    return false;
  end;


  func md_array_ends_with(const array: variant[]; path: integer[] = nil; value: variant[]): boolean;
    
    with Iterator.new(1, self.md_array_length(value)) do
      while __next do
        if self.md_array_get(array, -__index, path) <> self.md_array_get(value, -__index, path) then return false; end;
      end;
    end;

    return true;
  end;


  func md_array_ends_with_any(const array: variant; path: integer[] = nil; values: variant[]): boolean;
    
    with Iterator.new(1, self.md_array_length(values)) do
      while __next do
        if self.md_array_ends_with(array, path, values[__index]) then return true; end;
      end;
    end;

    return false;
  end;


  func md_array_slice(const array: variant[]; path: integer[] = nil; offset: integer = 1; length: variant = nil): variant[];

    offset = handle_offset(offset, self.md_array_length(array));

    with Iterator.new(offset, offset +handle_length(offset, length, self.md_array_length(array)) -1) do
      while __next do self.md_array_append(result, self.md_array_get(array, __index, path)); end;
    end;

    return result;
  end;


  func md_array_splice(var array: variant[]; value: variant[]; offset: integer = 1; length: variant = nil): variant[];

    -- функция извлекает подмассив с началом в offset и длиной length и заменяет его на элементы массива value

    offset = handle_offset(offset, self.md_array_length(array));

    with Iterator.new(offset, offset +handle_length(offset, length, self.md_array_length(array)) -1) do
      __end;

      while __previous do
        self.md_array_prepend(result, array[__index]);
        self.md_array_unset(array, __index);
      end;
    end;

    with Iterator.new(1, self.md_array_length(value)) do
      while __next do Kernel.System.insertInArray(array, offset +__index -1, value[__index]); end;
    end;

    return result;
  end;


  func md_array_concat(const arrays: variant[]): variant[];

    with Iterator.new(1, self.md_array_length(arrays)) do
      while __next do self.md_array_extend(result, array_from(arrays[__index])); end;
    end;

    return result;
  end;


  func md_array_repeat(const value: variant[]; count: integer): variant[];
    
    with Iterator.new(1, count) do
      self.md_array_extend(result, value);
    end;

    return result;
  end;


  proc md_array_swap(var array: variant[]; index, other_index: integer);
    
    var temp: variant;

    index       = handle_offset(index, self.md_array_length(array));
    other_index = handle_offset(other_index, self.md_array_length(array));

    temp = self.md_array_get(array, index);

    self.md_array_set(array, index, nil, self.md_array_get(array, other_index));
    self.md_array_set(array, other_index, nil, temp);
  end;


  proc md_array_reverse(var array: variant[]);

    with Iterator.new(1, var_int(self.md_array_length(array) /2)) do
      while __next do self.md_array_swap(array, __index, self.md_array_length(array) -__index +1); end;
    end;
  end;


  proc md_array_pad(var array: variant[]; direction: array_pad_direction; value: variant[]; length: integer);

    -- функция должна дополнить (значениями value) или сократить массив array, в зависимости от длины length,
    -- слева и/или справа, в зависимости от направления direction
    --
    -- используем алгоритм:
    -- узнаем, сколько элементов нужно добавить или удалить слева, это зависит от направления direction
    -- если массив меньше длины length, добавим полученное количество элементов слева и дополним до длины length справа
    -- если массив больше длины length, удалим полученное количество элементов слева и сократим до длины length справа

    var count: integer;


    if direction = self.ARRAY_PAD_LEFT then
      count = length -self.md_array_length(array);

    elsif direction = self.ARRAY_PAD_BOTH then
      count = var_int((length -self.md_array_length(array)) /2);

    elsif direction = self.ARRAY_PAD_RIGHT then
      count = 0;
    end;


    if self.md_array_length(array) < length then

      with Iterator.new(1, count) do
        with Iterator.new_children(__self, 1, self.md_array_length(value)) do
          while __parent.__next and __previous_loop do self.md_array_prepend(array, value[__index]); end;
        end;
      end;

      with Iterator.new(1, length -self.md_array_length(array)) do
        with Iterator.new_children(__self, 1, self.md_array_length(value)) do
          while __parent.__next and __next_loop do self.md_array_append(array, value[__index]); end;
        end;
      end;

    elsif self.md_array_length(array) > length then

      with Iterator.new(1, -count) do
        while __next do self.md_array_unset(array,  1  ); end;
      end;

      with Iterator.new(length +1, self.md_array_length(array)) do
        __end;
        while __previous do self.md_array_unset(array,  __index  ); end;
      end;
    end;
  end;


  proc md_array_sort(var array: variant[]; path: integer[] = nil);

    Kernel.System.sortArray(array, path);
  end;


  func md_array_each(const array: variant[]; path: integer[] = nil): array_method_each;
    
    return self.array_method_each.new(array, path);
  end;


  func md_array_filter(const array: variant[]; path: integer[] = nil): array_method_filter;
    
    return self.array_method_filter.new(array, path);
  end;


  func md_array_map(const array: variant[]; path: integer[] = nil): array_method_map;
    
    return self.array_method_map.new(array, path);
  end;


  func md_array_reduce(const array: variant[]; path: integer[] = nil; initial_value: variant): array_method_reduce;
    
    return self.array_method_reduce.new(array, path, initial_value);
  end;


  func md_array_implode(const array: variant[]; separator: string = " "): string;

    with self.md_array_reduce(array, nil, "") do
      while __next do __apply(__result +str(__item) +if (__at_end, "", separator)); end;
      __assign(result);
    end;

    return result;
  end;
end
